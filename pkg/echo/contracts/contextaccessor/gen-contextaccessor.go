// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package contextaccessor

import (
	"reflect"
	"strings"

	di "github.com/fluffy-bunny/sarulabsdi"
	"github.com/rs/zerolog/log"
)

// ReflectTypeIInternalEchoContextAccessor used when your service claims to implement IInternalEchoContextAccessor
var ReflectTypeIInternalEchoContextAccessor = di.GetInterfaceReflectType((*IInternalEchoContextAccessor)(nil))

// AddSingletonIInternalEchoContextAccessor adds a type that implements IInternalEchoContextAccessor
func AddSingletonIInternalEchoContextAccessor(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SINGLETON", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddSingleton(builder, implType, implementedTypes...)
}

// AddSingletonIInternalEchoContextAccessorWithMetadata adds a type that implements IInternalEchoContextAccessor
func AddSingletonIInternalEchoContextAccessorWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SINGLETON", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddSingletonWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddSingletonIInternalEchoContextAccessorByObj adds a prebuilt obj
func AddSingletonIInternalEchoContextAccessorByObj(builder *di.Builder, obj interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SINGLETON", reflect.TypeOf(obj), _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "obj",
		})
	di.AddSingletonWithImplementedTypesByObj(builder, obj, implementedTypes...)
}

// AddSingletonIInternalEchoContextAccessorByObjWithMetadata adds a prebuilt obj
func AddSingletonIInternalEchoContextAccessorByObjWithMetadata(builder *di.Builder, obj interface{}, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SINGLETON", reflect.TypeOf(obj), _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "obj",
		},
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByObjWithMetadata(builder, obj, metaData, implementedTypes...)
}

// AddSingletonIInternalEchoContextAccessorByFunc adds a type by a custom func
func AddSingletonIInternalEchoContextAccessorByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SINGLETON", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddSingletonWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddSingletonIInternalEchoContextAccessorByFuncWithMetadata adds a type by a custom func
func AddSingletonIInternalEchoContextAccessorByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SINGLETON", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddTransientIInternalEchoContextAccessor adds a type that implements IInternalEchoContextAccessor
func AddTransientIInternalEchoContextAccessor(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("TRANSIENT", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		})

	di.AddTransientWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddTransientIInternalEchoContextAccessorWithMetadata adds a type that implements IInternalEchoContextAccessor
func AddTransientIInternalEchoContextAccessorWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("TRANSIENT", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddTransientIInternalEchoContextAccessorByFunc adds a type by a custom func
func AddTransientIInternalEchoContextAccessorByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("TRANSIENT", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		})

	di.AddTransientWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddTransientIInternalEchoContextAccessorByFuncWithMetadata adds a type by a custom func
func AddTransientIInternalEchoContextAccessorByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("TRANSIENT", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddScopedIInternalEchoContextAccessor adds a type that implements IInternalEchoContextAccessor
func AddScopedIInternalEchoContextAccessor(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SCOPED", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddScopedWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddScopedIInternalEchoContextAccessorWithMetadata adds a type that implements IInternalEchoContextAccessor
func AddScopedIInternalEchoContextAccessorWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SCOPED", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddScopedWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddScopedIInternalEchoContextAccessorByFunc adds a type by a custom func
func AddScopedIInternalEchoContextAccessorByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SCOPED", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddScopedWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddScopedIInternalEchoContextAccessorByFuncWithMetadata adds a type by a custom func
func AddScopedIInternalEchoContextAccessorByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIInternalEchoContextAccessor)
	_logAddIInternalEchoContextAccessor("SCOPED", implType, _getImplementedIInternalEchoContextAccessorNames(implementedTypes...),
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logIInternalEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddScopedWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// RemoveAllIInternalEchoContextAccessor removes all IInternalEchoContextAccessor from the DI
func RemoveAllIInternalEchoContextAccessor(builder *di.Builder) {
	builder.RemoveAllByType(ReflectTypeIInternalEchoContextAccessor)
}

// GetIInternalEchoContextAccessorFromContainer alternative to SafeGetIInternalEchoContextAccessorFromContainer but panics of object is not present
func GetIInternalEchoContextAccessorFromContainer(ctn di.Container) IInternalEchoContextAccessor {
	return ctn.GetByType(ReflectTypeIInternalEchoContextAccessor).(IInternalEchoContextAccessor)
}

// GetManyIInternalEchoContextAccessorFromContainer alternative to SafeGetManyIInternalEchoContextAccessorFromContainer but panics of object is not present
func GetManyIInternalEchoContextAccessorFromContainer(ctn di.Container) []IInternalEchoContextAccessor {
	objs := ctn.GetManyByType(ReflectTypeIInternalEchoContextAccessor)
	var results []IInternalEchoContextAccessor
	for _, obj := range objs {
		results = append(results, obj.(IInternalEchoContextAccessor))
	}
	return results
}

// SafeGetIInternalEchoContextAccessorFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetIInternalEchoContextAccessorFromContainer(ctn di.Container) (IInternalEchoContextAccessor, error) {
	obj, err := ctn.SafeGetByType(ReflectTypeIInternalEchoContextAccessor)
	if err != nil {
		return nil, err
	}
	return obj.(IInternalEchoContextAccessor), nil
}

// GetIInternalEchoContextAccessorDefinition returns that last definition registered that this container can provide
func GetIInternalEchoContextAccessorDefinition(ctn di.Container) *di.Def {
	def := ctn.GetDefinitionByType(ReflectTypeIInternalEchoContextAccessor)
	return def
}

// GetIInternalEchoContextAccessorDefinitions returns all definitions that this container can provide
func GetIInternalEchoContextAccessorDefinitions(ctn di.Container) []*di.Def {
	defs := ctn.GetDefinitionsByType(ReflectTypeIInternalEchoContextAccessor)
	return defs
}

// SafeGetManyIInternalEchoContextAccessorFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetManyIInternalEchoContextAccessorFromContainer(ctn di.Container) ([]IInternalEchoContextAccessor, error) {
	objs, err := ctn.SafeGetManyByType(ReflectTypeIInternalEchoContextAccessor)
	if err != nil {
		return nil, err
	}
	var results []IInternalEchoContextAccessor
	for _, obj := range objs {
		results = append(results, obj.(IInternalEchoContextAccessor))
	}
	return results, nil
}

type _logIInternalEchoContextAccessorExtra struct {
	Name  string
	Value interface{}
}

func _logAddIInternalEchoContextAccessor(scopeType string, implType reflect.Type, interfaces string, extra ..._logIInternalEchoContextAccessorExtra) {
	infoEvent := log.Info().
		Str("DI", scopeType).
		Str("DI-I", interfaces).
		Str("DI-B", implType.Elem().String())

	for _, extra := range extra {
		infoEvent = infoEvent.Interface(extra.Name, extra.Value)
	}

	infoEvent.Send()

}
func _getImplementedIInternalEchoContextAccessorNames(implementedTypes ...reflect.Type) string {
	builder := strings.Builder{}
	for idx, implementedType := range implementedTypes {
		builder.WriteString(implementedType.Name())
		if idx < len(implementedTypes)-1 {
			builder.WriteString(", ")
		}
	}
	return builder.String()
}

// ReflectTypeIEchoContextAccessor used when your service claims to implement IEchoContextAccessor
var ReflectTypeIEchoContextAccessor = di.GetInterfaceReflectType((*IEchoContextAccessor)(nil))

// AddSingletonIEchoContextAccessor adds a type that implements IEchoContextAccessor
func AddSingletonIEchoContextAccessor(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SINGLETON", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddSingleton(builder, implType, implementedTypes...)
}

// AddSingletonIEchoContextAccessorWithMetadata adds a type that implements IEchoContextAccessor
func AddSingletonIEchoContextAccessorWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SINGLETON", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logIEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddSingletonWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddSingletonIEchoContextAccessorByObj adds a prebuilt obj
func AddSingletonIEchoContextAccessorByObj(builder *di.Builder, obj interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SINGLETON", reflect.TypeOf(obj), _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "obj",
		})
	di.AddSingletonWithImplementedTypesByObj(builder, obj, implementedTypes...)
}

// AddSingletonIEchoContextAccessorByObjWithMetadata adds a prebuilt obj
func AddSingletonIEchoContextAccessorByObjWithMetadata(builder *di.Builder, obj interface{}, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SINGLETON", reflect.TypeOf(obj), _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "obj",
		},
		_logIEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByObjWithMetadata(builder, obj, metaData, implementedTypes...)
}

// AddSingletonIEchoContextAccessorByFunc adds a type by a custom func
func AddSingletonIEchoContextAccessorByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SINGLETON", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddSingletonWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddSingletonIEchoContextAccessorByFuncWithMetadata adds a type by a custom func
func AddSingletonIEchoContextAccessorByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SINGLETON", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logIEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddSingletonWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddTransientIEchoContextAccessor adds a type that implements IEchoContextAccessor
func AddTransientIEchoContextAccessor(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("TRANSIENT", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		})

	di.AddTransientWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddTransientIEchoContextAccessorWithMetadata adds a type that implements IEchoContextAccessor
func AddTransientIEchoContextAccessorWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("TRANSIENT", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logIEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddTransientIEchoContextAccessorByFunc adds a type by a custom func
func AddTransientIEchoContextAccessorByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("TRANSIENT", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		})

	di.AddTransientWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddTransientIEchoContextAccessorByFuncWithMetadata adds a type by a custom func
func AddTransientIEchoContextAccessorByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("TRANSIENT", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logIEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddTransientWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddScopedIEchoContextAccessor adds a type that implements IEchoContextAccessor
func AddScopedIEchoContextAccessor(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SCOPED", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		})
	di.AddScopedWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddScopedIEchoContextAccessorWithMetadata adds a type that implements IEchoContextAccessor
func AddScopedIEchoContextAccessorWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SCOPED", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "type",
		},
		_logIEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})
	di.AddScopedWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddScopedIEchoContextAccessorByFunc adds a type by a custom func
func AddScopedIEchoContextAccessorByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SCOPED", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		})
	di.AddScopedWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddScopedIEchoContextAccessorByFuncWithMetadata adds a type by a custom func
func AddScopedIEchoContextAccessorByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIEchoContextAccessor)
	_logAddIEchoContextAccessor("SCOPED", implType, _getImplementedIEchoContextAccessorNames(implementedTypes...),
		_logIEchoContextAccessorExtra{
			Name:  "DI-BY",
			Value: "func",
		},
		_logIEchoContextAccessorExtra{
			Name:  "DI-M",
			Value: metaData,
		})

	di.AddScopedWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// RemoveAllIEchoContextAccessor removes all IEchoContextAccessor from the DI
func RemoveAllIEchoContextAccessor(builder *di.Builder) {
	builder.RemoveAllByType(ReflectTypeIEchoContextAccessor)
}

// GetIEchoContextAccessorFromContainer alternative to SafeGetIEchoContextAccessorFromContainer but panics of object is not present
func GetIEchoContextAccessorFromContainer(ctn di.Container) IEchoContextAccessor {
	return ctn.GetByType(ReflectTypeIEchoContextAccessor).(IEchoContextAccessor)
}

// GetManyIEchoContextAccessorFromContainer alternative to SafeGetManyIEchoContextAccessorFromContainer but panics of object is not present
func GetManyIEchoContextAccessorFromContainer(ctn di.Container) []IEchoContextAccessor {
	objs := ctn.GetManyByType(ReflectTypeIEchoContextAccessor)
	var results []IEchoContextAccessor
	for _, obj := range objs {
		results = append(results, obj.(IEchoContextAccessor))
	}
	return results
}

// SafeGetIEchoContextAccessorFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetIEchoContextAccessorFromContainer(ctn di.Container) (IEchoContextAccessor, error) {
	obj, err := ctn.SafeGetByType(ReflectTypeIEchoContextAccessor)
	if err != nil {
		return nil, err
	}
	return obj.(IEchoContextAccessor), nil
}

// GetIEchoContextAccessorDefinition returns that last definition registered that this container can provide
func GetIEchoContextAccessorDefinition(ctn di.Container) *di.Def {
	def := ctn.GetDefinitionByType(ReflectTypeIEchoContextAccessor)
	return def
}

// GetIEchoContextAccessorDefinitions returns all definitions that this container can provide
func GetIEchoContextAccessorDefinitions(ctn di.Container) []*di.Def {
	defs := ctn.GetDefinitionsByType(ReflectTypeIEchoContextAccessor)
	return defs
}

// SafeGetManyIEchoContextAccessorFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetManyIEchoContextAccessorFromContainer(ctn di.Container) ([]IEchoContextAccessor, error) {
	objs, err := ctn.SafeGetManyByType(ReflectTypeIEchoContextAccessor)
	if err != nil {
		return nil, err
	}
	var results []IEchoContextAccessor
	for _, obj := range objs {
		results = append(results, obj.(IEchoContextAccessor))
	}
	return results, nil
}

type _logIEchoContextAccessorExtra struct {
	Name  string
	Value interface{}
}

func _logAddIEchoContextAccessor(scopeType string, implType reflect.Type, interfaces string, extra ..._logIEchoContextAccessorExtra) {
	infoEvent := log.Info().
		Str("DI", scopeType).
		Str("DI-I", interfaces).
		Str("DI-B", implType.Elem().String())

	for _, extra := range extra {
		infoEvent = infoEvent.Interface(extra.Name, extra.Value)
	}

	infoEvent.Send()

}
func _getImplementedIEchoContextAccessorNames(implementedTypes ...reflect.Type) string {
	builder := strings.Builder{}
	for idx, implementedType := range implementedTypes {
		builder.WriteString(implementedType.Name())
		if idx < len(implementedTypes)-1 {
			builder.WriteString(", ")
		}
	}
	return builder.String()
}
