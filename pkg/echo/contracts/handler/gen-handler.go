// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package handler

import (
	"reflect"

	di "github.com/fluffy-bunny/sarulabsdi"
)

// ReflectTypeIHandler used when your service claims to implement IHandler
var ReflectTypeIHandler = di.GetInterfaceReflectType((*IHandler)(nil))

// AddSingletonIHandler adds a type that implements IHandler
func AddSingletonIHandler(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddSingleton(builder, implType, implementedTypes...)
}

// AddSingletonIHandlerWithMetadata adds a type that implements IHandler
func AddSingletonIHandlerWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddSingletonWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddSingletonIHandlerByObj adds a prebuilt obj
func AddSingletonIHandlerByObj(builder *di.Builder, obj interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddSingletonWithImplementedTypesByObj(builder, obj, implementedTypes...)
}

// AddSingletonIHandlerByObjWithMetadata adds a prebuilt obj
func AddSingletonIHandlerByObjWithMetadata(builder *di.Builder, obj interface{}, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddSingletonWithImplementedTypesByObjWithMetadata(builder, obj, metaData, implementedTypes...)
}

// AddSingletonIHandlerByFunc adds a type by a custom func
func AddSingletonIHandlerByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddSingletonWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddSingletonIHandlerByFuncWithMetadata adds a type by a custom func
func AddSingletonIHandlerByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddSingletonWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddTransientIHandler adds a type that implements IHandler
func AddTransientIHandler(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddTransientWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddTransientIHandlerWithMetadata adds a type that implements IHandler
func AddTransientIHandlerWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddTransientWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddTransientIHandlerByFunc adds a type by a custom func
func AddTransientIHandlerByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddTransientWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddTransientIHandlerByFuncWithMetadata adds a type by a custom func
func AddTransientIHandlerByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddTransientWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddScopedIHandler adds a type that implements IHandler
func AddScopedIHandler(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddScopedWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddScopedIHandlerWithMetadata adds a type that implements IHandler
func AddScopedIHandlerWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddScopedWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddScopedIHandlerByFunc adds a type by a custom func
func AddScopedIHandlerByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddScopedWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddScopedIHandlerByFuncWithMetadata adds a type by a custom func
func AddScopedIHandlerByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandler)
	di.AddScopedWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// RemoveAllIHandler removes all IHandler from the DI
func RemoveAllIHandler(builder *di.Builder) {
	builder.RemoveAllByType(ReflectTypeIHandler)
}

// GetIHandlerFromContainer alternative to SafeGetIHandlerFromContainer but panics of object is not present
func GetIHandlerFromContainer(ctn di.Container) IHandler {
	return ctn.GetByType(ReflectTypeIHandler).(IHandler)
}

// GetManyIHandlerFromContainer alternative to SafeGetManyIHandlerFromContainer but panics of object is not present
func GetManyIHandlerFromContainer(ctn di.Container) []IHandler {
	objs := ctn.GetManyByType(ReflectTypeIHandler)
	var results []IHandler
	for _, obj := range objs {
		results = append(results, obj.(IHandler))
	}
	return results
}

// SafeGetIHandlerFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetIHandlerFromContainer(ctn di.Container) (IHandler, error) {
	obj, err := ctn.SafeGetByType(ReflectTypeIHandler)
	if err != nil {
		return nil, err
	}
	return obj.(IHandler), nil
}

// GetIHandlerDefinition returns that last definition registered that this container can provide
func GetIHandlerDefinition(ctn di.Container) *di.Def {
	def := ctn.GetDefinitionByType(ReflectTypeIHandler)
	return def
}

// GetIHandlerDefinitions returns all definitions that this container can provide
func GetIHandlerDefinitions(ctn di.Container) []*di.Def {
	defs := ctn.GetDefinitionsByType(ReflectTypeIHandler)
	return defs
}

// SafeGetManyIHandlerFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetManyIHandlerFromContainer(ctn di.Container) ([]IHandler, error) {
	objs, err := ctn.SafeGetManyByType(ReflectTypeIHandler)
	if err != nil {
		return nil, err
	}
	var results []IHandler
	for _, obj := range objs {
		results = append(results, obj.(IHandler))
	}
	return results, nil
}

// ReflectTypeIHandlerFactory used when your service claims to implement IHandlerFactory
var ReflectTypeIHandlerFactory = di.GetInterfaceReflectType((*IHandlerFactory)(nil))

// AddSingletonIHandlerFactory adds a type that implements IHandlerFactory
func AddSingletonIHandlerFactory(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddSingleton(builder, implType, implementedTypes...)
}

// AddSingletonIHandlerFactoryWithMetadata adds a type that implements IHandlerFactory
func AddSingletonIHandlerFactoryWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddSingletonWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddSingletonIHandlerFactoryByObj adds a prebuilt obj
func AddSingletonIHandlerFactoryByObj(builder *di.Builder, obj interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddSingletonWithImplementedTypesByObj(builder, obj, implementedTypes...)
}

// AddSingletonIHandlerFactoryByObjWithMetadata adds a prebuilt obj
func AddSingletonIHandlerFactoryByObjWithMetadata(builder *di.Builder, obj interface{}, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddSingletonWithImplementedTypesByObjWithMetadata(builder, obj, metaData, implementedTypes...)
}

// AddSingletonIHandlerFactoryByFunc adds a type by a custom func
func AddSingletonIHandlerFactoryByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddSingletonWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddSingletonIHandlerFactoryByFuncWithMetadata adds a type by a custom func
func AddSingletonIHandlerFactoryByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddSingletonWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddTransientIHandlerFactory adds a type that implements IHandlerFactory
func AddTransientIHandlerFactory(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddTransientWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddTransientIHandlerFactoryWithMetadata adds a type that implements IHandlerFactory
func AddTransientIHandlerFactoryWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddTransientWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddTransientIHandlerFactoryByFunc adds a type by a custom func
func AddTransientIHandlerFactoryByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddTransientWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddTransientIHandlerFactoryByFuncWithMetadata adds a type by a custom func
func AddTransientIHandlerFactoryByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddTransientWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// AddScopedIHandlerFactory adds a type that implements IHandlerFactory
func AddScopedIHandlerFactory(builder *di.Builder, implType reflect.Type, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddScopedWithImplementedTypes(builder, implType, implementedTypes...)
}

// AddScopedIHandlerFactoryWithMetadata adds a type that implements IHandlerFactory
func AddScopedIHandlerFactoryWithMetadata(builder *di.Builder, implType reflect.Type, metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddScopedWithImplementedTypesWithMetadata(builder, implType, metaData, implementedTypes...)
}

// AddScopedIHandlerFactoryByFunc adds a type by a custom func
func AddScopedIHandlerFactoryByFunc(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddScopedWithImplementedTypesByFunc(builder, implType, build, implementedTypes...)
}

// AddScopedIHandlerFactoryByFuncWithMetadata adds a type by a custom func
func AddScopedIHandlerFactoryByFuncWithMetadata(builder *di.Builder, implType reflect.Type, build func(ctn di.Container) (interface{}, error), metaData map[string]interface{}, implementedTypes ...reflect.Type) {
	implementedTypes = append(implementedTypes, ReflectTypeIHandlerFactory)
	di.AddScopedWithImplementedTypesByFuncWithMetadata(builder, implType, build, metaData, implementedTypes...)
}

// RemoveAllIHandlerFactory removes all IHandlerFactory from the DI
func RemoveAllIHandlerFactory(builder *di.Builder) {
	builder.RemoveAllByType(ReflectTypeIHandlerFactory)
}

// GetIHandlerFactoryFromContainer alternative to SafeGetIHandlerFactoryFromContainer but panics of object is not present
func GetIHandlerFactoryFromContainer(ctn di.Container) IHandlerFactory {
	return ctn.GetByType(ReflectTypeIHandlerFactory).(IHandlerFactory)
}

// GetManyIHandlerFactoryFromContainer alternative to SafeGetManyIHandlerFactoryFromContainer but panics of object is not present
func GetManyIHandlerFactoryFromContainer(ctn di.Container) []IHandlerFactory {
	objs := ctn.GetManyByType(ReflectTypeIHandlerFactory)
	var results []IHandlerFactory
	for _, obj := range objs {
		results = append(results, obj.(IHandlerFactory))
	}
	return results
}

// SafeGetIHandlerFactoryFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetIHandlerFactoryFromContainer(ctn di.Container) (IHandlerFactory, error) {
	obj, err := ctn.SafeGetByType(ReflectTypeIHandlerFactory)
	if err != nil {
		return nil, err
	}
	return obj.(IHandlerFactory), nil
}

// GetIHandlerFactoryDefinition returns that last definition registered that this container can provide
func GetIHandlerFactoryDefinition(ctn di.Container) *di.Def {
	def := ctn.GetDefinitionByType(ReflectTypeIHandlerFactory)
	return def
}

// GetIHandlerFactoryDefinitions returns all definitions that this container can provide
func GetIHandlerFactoryDefinitions(ctn di.Container) []*di.Def {
	defs := ctn.GetDefinitionsByType(ReflectTypeIHandlerFactory)
	return defs
}

// SafeGetManyIHandlerFactoryFromContainer trys to get the object by type, will not panic, returns nil and error
func SafeGetManyIHandlerFactoryFromContainer(ctn di.Container) ([]IHandlerFactory, error) {
	objs, err := ctn.SafeGetManyByType(ReflectTypeIHandlerFactory)
	if err != nil {
		return nil, err
	}
	var results []IHandlerFactory
	for _, obj := range objs {
		results = append(results, obj.(IHandlerFactory))
	}
	return results, nil
}
