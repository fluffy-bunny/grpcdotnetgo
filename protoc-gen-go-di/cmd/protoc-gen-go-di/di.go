package main

import (
	"encoding/json"
	"fmt"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	protobuf_proto "google.golang.org/protobuf/proto"
)

const (
	reflectPackage                     = protogen.GoImportPath("reflect")
	contextPackage                     = protogen.GoImportPath("context")
	errorsPackage                      = protogen.GoImportPath("errors")
	grpcPackage                        = protogen.GoImportPath("google.golang.org/grpc")
	grpcStatusPackage                  = protogen.GoImportPath("google.golang.org/grpc/status")
	grpcCodesPackage                   = protogen.GoImportPath("google.golang.org/grpc/codes")
	protoreflectPackage                = protogen.GoImportPath("google.golang.org/protobuf/reflect/protoreflect")
	diPackage                          = protogen.GoImportPath("github.com/fluffy-bunny/sarulabsdi")
	grpcDIInternalPackage              = protogen.GoImportPath("github.com/fluffy-bunny/grpcdotnetgo/pkg")
	grpcDIInternalPackageContractsGRPC = protogen.GoImportPath("github.com/fluffy-bunny/grpcdotnetgo/pkg/contracts/grpc")
	grpcDIInternalRuntimePackage       = protogen.GoImportPath("github.com/fluffy-bunny/grpcdotnetgo/pkg/runtime")
	grpcDIProtoError                   = protogen.GoImportPath("github.com/fluffy-bunny/grpcdotnetgo/pkg/proto/error")
	diContextPackage                   = protogen.GoImportPath("github.com/fluffy-bunny/grpcdotnetgo/pkg/middleware/dicontext")
	protocGenGoDiPackage               = protogen.GoImportPath("github.com/fluffy-bunny/grpcdotnetgo/protoc-gen-go-di/pkg")
	grpcGatewayRuntimePackage          = protogen.GoImportPath("github.com/grpc-ecosystem/grpc-gateway/v2/runtime")
)

type genFileContext struct {
	packageName string
	uniqueRunID string
	gen         *protogen.Plugin
	file        *protogen.File
	filename    string
	g           *protogen.GeneratedFile
}

func isServiceIgnored(service *protogen.Service) bool {
	// Look for a comment consisting of "di:ignore"
	const ignore = "di:ignore"
	for _, comment := range service.Comments.LeadingDetached {
		if strings.Contains(string(comment), ignore) {
			return true
		}
	}

	return strings.Contains(string(service.Comments.Leading), ignore)
}
func newGenFileContext(gen *protogen.Plugin, file *protogen.File) *genFileContext {
	ctx := &genFileContext{
		file:        file,
		gen:         gen,
		uniqueRunID: randomString(32),
		packageName: string(file.GoPackageName),
		filename:    file.GeneratedFilenamePrefix + "_di.pb.go",
	}
	ctx.g = gen.NewGeneratedFile(ctx.filename, file.GoImportPath)
	return ctx
}

// MethodInfo type
type MethodInfo struct {
	NewResponseWithErrorFunc string
	NewResponseFunc          string
	ExecuteFunc              string
}
type methodGenContext struct {
	MethodInfo     *MethodInfo
	ProtogenMethod *protogen.Method
	gen            *protogen.Plugin
	file           *protogen.File
	g              *protogen.GeneratedFile
	service        *protogen.Service
	uniqueRunID    string
}
type serviceGenContext struct {
	packageName     string
	MethodMapGenCtx map[string]*methodGenContext
	gen             *protogen.Plugin
	file            *protogen.File
	g               *protogen.GeneratedFile
	service         *protogen.Service
	uniqueRunID     string
}

func newServiceGenContext(packageName string, uniqueRunId string, gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) *serviceGenContext {
	ctx := &serviceGenContext{
		packageName:     packageName,
		uniqueRunID:     uniqueRunId,
		gen:             gen,
		file:            file,
		g:               g,
		service:         service,
		MethodMapGenCtx: make(map[string]*methodGenContext),
	}
	return ctx
}
func newMethodGenContext(uniqueRunId string, protogenMethod *protogen.Method, gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) *methodGenContext {
	ctx := &methodGenContext{
		uniqueRunID:    uniqueRunId,
		MethodInfo:     &MethodInfo{},
		ProtogenMethod: protogenMethod,
		gen:            gen,
		file:           file,
		g:              g,
		service:        service,
	}
	return ctx
}

// generateFile generates a _di.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	ctx := newGenFileContext(gen, file)
	g := ctx.g

	// Default to skip - will unskip if there is a service to generate
	g.Skip()

	g.P("// Code generated by protoc-gen-go-di. DO NOT EDIT.")
	if *grpcGatewayEnabled {
		g.P("// Code generated grpcGateway")
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	ctx.generateFileContent()
	return g
}
func getFileName(file *protogen.File) string {
	v := strings.Split(file.GeneratedFilenamePrefix, "/")
	idx := len(v) - 1
	return v[idx]
}

// generateFileContent generates the DI service definitions, excluding the package statement.
func (s *genFileContext) generateFileContent() {
	gen := s.gen
	file := s.file

	g := s.g
	//proto := file.Proto
	//g.P("/*  file.Proto")
	//g.P(prettyJSON(proto))
	//g.P("*/")

	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the grpc package it is being compiled against.")
	g.P("const _ = ", grpcDIInternalPackage.Ident("SupportPackageIsVersion7"))
	g.P()

	g.P("func setNewField_", s.uniqueRunID, "(dst interface{}, field string) {")
	g.P("\tv := ", reflectPackage.Ident("ValueOf"), "(dst).Elem().FieldByName(field)")
	g.P("\tif v.IsValid() {")
	g.P("\t\tv.Set(", reflectPackage.Ident("New"), "(v.Type().Elem()))")
	g.P("\t}")
	g.P("}")

	var serviceGenCtxs []*serviceGenContext
	// Generate each service
	for _, service := range file.Services {
		// Check if this service is ignored for DI purposes
		if isServiceIgnored(service) {
			continue
		}

		// Now we have something to generate
		g.Unskip()

		serviceGenCtx := newServiceGenContext(s.packageName, s.uniqueRunID, gen, file, g, service)
		serviceGenCtx.genService()
		serviceGenCtxs = append(serviceGenCtxs, serviceGenCtx)
	}

	g.P("// New_", getFileName(file), "FullMethodNameSlice create a new map of fullMethodNames to []string")
	g.P("// i.e. /helloworld.Greeter/SayHello ")
	g.P("func New_", getFileName(file), "FullMethodNameSlice() []string {")
	g.P("    slice := []string {")
	for _, sctx := range serviceGenCtxs {
		for k := range sctx.MethodMapGenCtx {
			g.P("        \"", k, "\",")
		}
	}
	g.P("    }")
	g.P("    return slice")
	g.P("}")

	g.P("func init() {")
	g.P("  r := New_", getFileName(file), "FullMethodNameSlice()")
	g.P("  ", protocGenGoDiPackage.Ident("AddFullMethodNameSliceToMap(r)"))
	g.P("}")

	g.P("// ", getFileName(file), "FullMethodNameEmptyResponseMap keys match that of grpc.UnaryServerInfo.FullMethodName")
	g.P("// i.e. /helloworld.Greeter/SayHello ")
	g.P("var ", getFileName(file), "FullMethodNameEmptyResponseMap = map[string]func()interface{} {")
	for _, sctx := range serviceGenCtxs {
		for k, v := range sctx.MethodMapGenCtx {
			g.P("    \"", k, "\": ", v.MethodInfo.NewResponseFunc, ",")
		}
	}
	g.P("}")

	g.P("// Get_", getFileName(file), "FullEmptyResponseFromFullMethodName ...")
	g.P("func Get_", getFileName(file), "FullEmptyResponseFromFullMethodName(fullMethodName string) func() interface{} {")
	g.P("  v,ok := ", getFileName(file), "FullMethodNameEmptyResponseMap[fullMethodName]")
	g.P("  if ok {")
	g.P("    return v")
	g.P("  }")
	g.P("  return nil")
	g.P("}")

	g.P("// ", getFileName(file), "FullMethodNameWithErrorResponseMap keys match that of grpc.UnaryServerInfo.FullMethodName")
	g.P("// i.e. /helloworld.Greeter/SayHello ")
	g.P("var ", getFileName(file), "FullMethodNameWithErrorResponseMap = map[string]func()interface{} {")
	for _, sctx := range serviceGenCtxs {
		for k, v := range sctx.MethodMapGenCtx {
			g.P("    \"", k, "\": ", v.MethodInfo.NewResponseWithErrorFunc, ",")
		}
	}
	g.P("}")

	g.P("// Get_", getFileName(file), "FullEmptyResponseWithErrorFromFullMethodName ...")
	g.P("func Get_", getFileName(file), "FullEmptyResponseWithErrorFromFullMethodName(fullMethodName string) func() interface{} {")
	g.P("  v,ok := ", getFileName(file), "FullMethodNameWithErrorResponseMap[fullMethodName]")
	g.P("  if ok {")
	g.P("    return v")
	g.P("  }")
	g.P("  return nil")
	g.P("}")

	for _, sctx := range serviceGenCtxs {
		g.P("// M_", getFileName(file), "_", sctx.service.GoName, "FullMethodNameExecuteMap keys match that of grpc.UnaryServerInfo.FullMethodName")
		g.P("var M_", getFileName(file), "_", sctx.service.GoName,
			fmt.Sprintf("FullMethodNameExecuteMap = map[string]func(service I%vServer, ctx context.Context, request interface{}) (interface{}, error) {", sctx.service.GoName))
		for k, v := range sctx.MethodMapGenCtx {
			g.P("    \"", k, "\": ", v.MethodInfo.ExecuteFunc, ",")
		}

		g.P("}")
	}
}

func (s *serviceGenContext) genService() {
	gen := s.gen
	file := s.file
	proto := file.Proto
	g := s.g
	service := s.service

	// IServiceEndpointRegistration
	serviceEndpointRegistrationName := fmt.Sprintf("%vEndpointRegistration", service.GoName)
	interfaceServerName := fmt.Sprintf("I%vServer", service.GoName)
	mustEmbedUnimplementedName := fmt.Sprintf("mustEmbedUnimplemented%vServer", service.GoName)
	interfaceDownstreamServiceName := fmt.Sprintf("I%vService", service.GoName)

	isStreamingServer := false
	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() {
			isStreamingServer = true
			break
		}
	}
	if isStreamingServer {
		// we have an unimplemented server that already implements the interface
		// does nothing
		g.P("")
		g.P("// We have a streaming service", service.GoName, "")
		g.P("")
	}
	isHTTPService := false
	for _, method := range service.Methods {
		extHTTP := protobuf_proto.GetExtension(method.Desc.Options(), annotations.E_Http)
		if extHTTP != nil && extHTTP != annotations.E_Http.InterfaceOf(annotations.E_Http.Zero()) {
			isHTTPService = true
			break
		}
	}
	if isHTTPService {
		// we have an unimplemented server that already implements the interface
		// does nothing
		g.P("")
		g.P("// We have an HTTP service using grpc-gateway", service.GoName, "")
		g.P("")
	} else {
		g.P("")
		g.P("// We have NO HTTP service:", service.GoName, "")
		g.P("")

	}

	unimplementedServerEndpointRegistrationName := fmt.Sprintf("Unimplemented%sServerEndpointRegistration", service.GoName)
	g.P("type ", unimplementedServerEndpointRegistrationName, " struct {")
	g.P("}")
	g.P()
	g.P("func (", unimplementedServerEndpointRegistrationName, ") RegisterGatewayHandler(gwmux *", grpcGatewayRuntimePackage.Ident("ServeMux"),
		",conn *", grpcPackage.Ident("ClientConn"), ") {")
	g.P("}")
	g.P()
	// Define the ServiceEndpointRegistration implementation
	//----------------------------------------------------------------------------------------------
	g.P("// ", serviceEndpointRegistrationName, " defines the grpc server endpoint registration")
	g.P("type ", serviceEndpointRegistrationName, " struct {")
	g.P("}")
	g.P()
	g.P("// ", serviceEndpointRegistrationName, " defines the grpc server endpoint registration")
	g.P("type ", serviceEndpointRegistrationName, "V2 struct {")
	g.P(unimplementedServerEndpointRegistrationName)

	g.P("}")
	g.P()
	// Add the DI Singleton registration
	//----------------------------------------------------------------------------------------------
	typeServiceEndpointRegistrationName := fmt.Sprintf("Type%s", serviceEndpointRegistrationName)
	g.P("// ", typeServiceEndpointRegistrationName, " reflect type")
	g.P("var ", typeServiceEndpointRegistrationName, " = ", diPackage.Ident("GetInterfaceReflectType"), "((*", serviceEndpointRegistrationName, ")(nil))")
	g.P()
	g.P("// Add", serviceEndpointRegistrationName, " adds a type that implements IServiceEndpointRegistration")
	g.P("func Add", serviceEndpointRegistrationName, "(builder *", diPackage.Ident("Builder"), ",implType ", reflectPackage.Ident("Type"), ")", " {")
	g.P("   ", grpcDIInternalPackageContractsGRPC.Ident("AddSingletonIServiceEndpointRegistration"), "(builder,reflect.TypeOf(&", serviceEndpointRegistrationName, "{}))")
	g.P("	AddScoped", interfaceDownstreamServiceName, "(builder,implType)")
	g.P("}")
	g.P()
	g.P("// Add", serviceEndpointRegistrationName, " adds a type that implements IServiceEndpointRegistration")
	g.P("func Add", serviceEndpointRegistrationName, "V2(builder *", diPackage.Ident("Builder"), ",implType ", reflectPackage.Ident("Type"), ")", " {")
	g.P("   ", grpcDIInternalPackageContractsGRPC.Ident("AddSingletonIServiceEndpointRegistration"), "(builder,reflect.TypeOf(&", serviceEndpointRegistrationName, "V2{}))")
	g.P("  AddScoped", interfaceServerName, "(builder,implType)")
	g.P("}")
	g.P()
	// Add the methods
	//----------------------------------------------------------------------------------------------
	g.P("// GetName returns the name of the service")
	g.P("func (s *", serviceEndpointRegistrationName, ") GetName() string {")
	g.P("  return \"", service.GoName, "\"")
	g.P("}")
	g.P()
	g.P("// GetName returns the name of the service")
	g.P("func (s *", serviceEndpointRegistrationName, "V2) GetName() string {")
	g.P("  return \"", service.GoName, "\"")
	g.P("}")
	g.P()
	g.P("// GetNewClient returns a new instance of a grpc client")
	g.P("func (s *", serviceEndpointRegistrationName, ") GetNewClient(cc ", grpcPackage.Ident("ClientConnInterface"), " )interface{} {")
	g.P("	return New", service.GoName, "Client(cc)")
	g.P("}")
	g.P()
	g.P("// GetNewClient returns a new instance of a grpc client")
	g.P("func (s *", serviceEndpointRegistrationName, "V2) GetNewClient(cc ", grpcPackage.Ident("ClientConnInterface"), " )interface{} {")
	g.P("	return New", service.GoName, "Client(cc)")
	g.P("}")
	g.P()
	if !isStreamingServer {
		if *grpcGatewayEnabled && isHTTPService {
			g.P("// Registery gateway handler")
			g.P("func (s *", serviceEndpointRegistrationName, ") RegisterGatewayHandler(gwmux *", grpcGatewayRuntimePackage.Ident("ServeMux"),
				",conn *", grpcPackage.Ident("ClientConn"), ") {")
			g.P("   ", "Register", service.GoName, "Handler(", contextPackage.Ident("Background()"), ", gwmux, conn)")
			g.P("}")
			g.P()
		}
	}
	g.P("// RegisterEndpoint registers a DI server")
	g.P("func (s *", serviceEndpointRegistrationName, ") RegisterEndpoint(server *", grpcPackage.Ident("Server"), ") interface{} {")
	g.P("  endpoint := Register", service.GoName, "ServerDI(server)")
	g.P("  return endpoint")
	g.P("}")
	g.P()
	g.P("// RegisterEndpoint registers a DI server")
	g.P("func (s *", serviceEndpointRegistrationName, "V2) RegisterEndpoint(server *", grpcPackage.Ident("Server"), ") interface{} {")
	g.P("  endpoint := Register", service.GoName, "ServerDIV2(server)")
	g.P("  return endpoint")
	g.P("}")
	g.P()
	if !isStreamingServer {
		if *grpcGatewayEnabled && isHTTPService {
			g.P("// Registery gateway handler")
			g.P("func (s *", serviceEndpointRegistrationName, "V2) RegisterGatewayHandler(gwmux *", grpcGatewayRuntimePackage.Ident("ServeMux"),
				",conn *", grpcPackage.Ident("ClientConn"), ") {")
			g.P("   ", "Register", service.GoName, "Handler(", contextPackage.Ident("Background()"), ", gwmux, conn)")
			g.P("}")
			g.P()
		}
	}
	g.P("// RegisterEndpoint registers a DI server")
	g.P("func (s *", serviceEndpointRegistrationName, "V2) RegisterEndpointV2(server *", grpcPackage.Ident("Server"), ") interface{} {")
	g.P("  endpoint := Register", service.GoName, "ServerDIV2(server)")
	g.P("  return endpoint")
	g.P("}")
	g.P()
	g.P("// ", interfaceServerName, " defines the grpc server")
	g.P("type ", interfaceServerName, " interface {")
	g.P("  	", mustEmbedUnimplementedName, "()")
	for _, method := range service.Methods {
		methodGenCtx := newMethodGenContext(s.uniqueRunID, method, gen, file, g, service)
		g.P(methodGenCtx.serverSignature())
	}
	g.P("}")
	g.P()

	unimplementedExServerName := fmt.Sprintf("Unimplemented%vServerEx", service.GoName)
	g.P("// ", unimplementedExServerName, " defines the grpc server")
	g.P("type ", unimplementedExServerName, " struct {")
	g.P("  UnimplemtedErrorResponse func() error")
	g.P("}")
	g.P("func (", unimplementedExServerName, ") ",
		"mustEmbedUnimplemented", service.GoName, "Server(){}")

	for _, method := range service.Methods {
		methodGenCtx := newMethodGenContext(s.uniqueRunID, method, gen, file, g, service)
		g.P("func (u ", unimplementedExServerName, ") ", methodGenCtx.serverSignature(), "{")
		g.P("  if u.UnimplemtedErrorResponse != nil {")
		g.P("    return nil, u.UnimplemtedErrorResponse()")
		g.P("  }")
		g.P("  return nil, ", grpcStatusPackage.Ident("Error"), "(", grpcCodesPackage.Ident("Unimplemented"), ",\"method ", method.GoName, " not implemented\")")
		g.P("}")
	}

	g.P("// ", interfaceDownstreamServiceName, " defines the required downstream service interface")
	g.P("type ", interfaceDownstreamServiceName, " interface {")
	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := newMethodGenContext(s.uniqueRunID, method, gen, file, g, service)
		methodGenCtx.genDownstreamMethodSignature()
		s.MethodMapGenCtx[key] = methodGenCtx
	}
	g.P("}")
	g.P()

	typeServerInterfaceName := fmt.Sprintf("Type%s", interfaceServerName)
	typeDownstreamServiceInterfaceName := fmt.Sprintf("Type%s", interfaceDownstreamServiceName)
	// user reflection once to record the type
	g.P("// ", typeServerInterfaceName, " reflect type")
	g.P("var ", typeServerInterfaceName, " = ", diPackage.Ident("GetInterfaceReflectType"), "((*", interfaceDownstreamServiceName, ")(nil))")

	g.P("// ", typeDownstreamServiceInterfaceName, " reflect type")
	g.P("var ", typeDownstreamServiceInterfaceName, " = ", diPackage.Ident("GetInterfaceReflectType"), "((*", interfaceDownstreamServiceName, ")(nil))")

	// making type look like sarulabsdi genny types
	typeServerInterfaceName = fmt.Sprintf("ReflectType%v", interfaceServerName)
	g.P("// ", typeServerInterfaceName, " reflect type")
	g.P("var ", typeServerInterfaceName, " = ", diPackage.Ident("GetInterfaceReflectType"), "((*", interfaceServerName, ")(nil))")

	typeDownstreamServiceInterfaceName = fmt.Sprintf("ReflectType%v", interfaceDownstreamServiceName)
	g.P("// ", typeDownstreamServiceInterfaceName, " reflect type")
	g.P("var ", typeDownstreamServiceInterfaceName, " = ", diPackage.Ident("GetInterfaceReflectType"), "((*", interfaceDownstreamServiceName, ")(nil))")

	g.P("type Get", service.GoName, "Client func() (", service.GoName, "Client,error)")

	// DI Helpers

	// making type look like sarulabsdi genny types

	g.P("// AddSingleton", interfaceServerName, "ByObj adds a prebuilt obj")
	g.P("func AddSingleton", interfaceServerName, "ByObj(builder *", diPackage.Ident("Builder"), ", obj interface{})", " {")
	g.P(diPackage.Ident("AddSingletonWithImplementedTypesByObj"), "(builder,obj,", typeServerInterfaceName, ",)")
	g.P("}")
	g.P()

	g.P("// AddSingleton", interfaceServerName, " adds a type that implements ", interfaceServerName)
	g.P("func AddSingleton", interfaceServerName, "(builder *", diPackage.Ident("Builder"), ",implType ", reflectPackage.Ident("Type"), ")", " {")
	g.P(diPackage.Ident("AddSingletonWithImplementedTypes"), "(builder,implType,", typeServerInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// AddSingleton", interfaceServerName, "ByFunc adds a type by a custom func")
	g.P("func AddSingleton", interfaceServerName, "ByFunc(builder *", diPackage.Ident("Builder"), ", implType ", reflectPackage.Ident("Type"), ", build func(ctn ", diPackage.Ident("Container"), ") (interface{}, error)) {")
	g.P(diPackage.Ident("AddSingletonWithImplementedTypesByFunc"), "(builder, implType, build,", typeServerInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// AddSingleton", interfaceDownstreamServiceName, "ByObj adds a prebuilt obj")
	g.P("func AddSingleton", interfaceDownstreamServiceName, "ByObj(builder *", diPackage.Ident("Builder"), ", obj interface{})", " {")
	g.P(diPackage.Ident("AddSingletonWithImplementedTypesByObj"), "(builder,obj,", typeDownstreamServiceInterfaceName, ",)")
	g.P("}")
	g.P()

	g.P("// AddSingleton", interfaceDownstreamServiceName, " adds a type that implements ", interfaceDownstreamServiceName)
	g.P("func AddSingleton", interfaceDownstreamServiceName, "(builder *", diPackage.Ident("Builder"), ",implType ", reflectPackage.Ident("Type"), ")", " {")
	g.P(diPackage.Ident("AddSingletonWithImplementedTypes"), "(builder,implType,", typeDownstreamServiceInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// AddSingleton", interfaceDownstreamServiceName, "ByFunc adds a type by a custom func")
	g.P("func AddSingleton", interfaceDownstreamServiceName, "ByFunc(builder *", diPackage.Ident("Builder"), ", implType ", reflectPackage.Ident("Type"), ", build func(ctn ", diPackage.Ident("Container"), ") (interface{}, error)) {")
	g.P(diPackage.Ident("AddSingletonWithImplementedTypesByFunc"), "(builder, implType, build,", typeDownstreamServiceInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// AddTransient", interfaceDownstreamServiceName, " adds a type that implements ", interfaceDownstreamServiceName)
	g.P("func AddTransient", interfaceDownstreamServiceName, "(builder *", diPackage.Ident("Builder"), ",implType ", reflectPackage.Ident("Type"), ")", " {")
	g.P(diPackage.Ident("AddTransientWithImplementedTypes"), "(builder,implType,", typeDownstreamServiceInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// AddTransient", interfaceDownstreamServiceName, "ByFunc adds a type by a custom func")
	g.P("func AddTransient", interfaceDownstreamServiceName, "ByFunc(builder *", diPackage.Ident("Builder"), ", implType ", reflectPackage.Ident("Type"), ", build func(ctn ", diPackage.Ident("Container"), ") (interface{}, error)) {")
	g.P(diPackage.Ident("AddTransientWithImplementedTypesByFunc"), "(builder, implType, build,", typeDownstreamServiceInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// AddScoped", interfaceServerName, " adds a type that implements ", interfaceServerName)
	g.P("func AddScoped", interfaceServerName, "(builder *", diPackage.Ident("Builder"), ",implType ", reflectPackage.Ident("Type"), ")", " {")
	g.P(diPackage.Ident("AddScopedWithImplementedTypes"), "(builder,implType,", typeServerInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// AddScoped", interfaceDownstreamServiceName, " adds a type that implements ", interfaceDownstreamServiceName)
	g.P("func AddScoped", interfaceDownstreamServiceName, "(builder *", diPackage.Ident("Builder"), ",implType ", reflectPackage.Ident("Type"), ")", " {")
	g.P(diPackage.Ident("AddScopedWithImplementedTypes"), "(builder,implType,", typeDownstreamServiceInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// AddScoped", interfaceDownstreamServiceName, "ByFunc adds a type by a custom func")
	g.P("func AddScoped", interfaceDownstreamServiceName, "ByFunc(builder *", diPackage.Ident("Builder"), ", implType ", reflectPackage.Ident("Type"), ", build func(ctn ", diPackage.Ident("Container"), ") (interface{}, error)) {")
	g.P(diPackage.Ident("AddScopedWithImplementedTypesByFunc"), "(builder, implType, build,", typeDownstreamServiceInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// RemoveAll", interfaceDownstreamServiceName, " removes all IBillingService from the DI")
	g.P("func RemoveAll", interfaceDownstreamServiceName, "(builder *", diPackage.Ident("Builder"), ")  {")
	g.P("builder.RemoveAllByType(", typeDownstreamServiceInterfaceName, ")")
	g.P("}")
	g.P()

	g.P("// Get", service.GoName, "ServiceFromContainer fetches the downstream di.Request scoped service")
	g.P("func Get", service.GoName, "ServiceFromContainer(ctn ", diPackage.Ident("Container"), ") ", interfaceDownstreamServiceName, " {")
	g.P("return ctn.GetByType(", typeDownstreamServiceInterfaceName, ").(", interfaceDownstreamServiceName, ")")
	g.P("}")
	g.P()
	g.P("// Get", service.GoName, "ServerFromContainer fetches the downstream di.Request scoped service")
	g.P("func Get", service.GoName, "ServerFromContainer(ctn ", diPackage.Ident("Container"), ") ", interfaceServerName, " {")
	g.P("return ctn.GetByType(", typeServerInterfaceName, ").(", interfaceServerName, ")")
	g.P("}")
	g.P()
	// making type look like sarulabsdi genny types
	g.P("// Get", interfaceDownstreamServiceName, "FromContainer fetches the downstream di.Request scoped service")
	g.P("func Get", interfaceDownstreamServiceName, "FromContainer(ctn ", diPackage.Ident("Container"), ") ", interfaceDownstreamServiceName, " {")
	g.P("return ctn.GetByType(", typeDownstreamServiceInterfaceName, ").(", interfaceDownstreamServiceName, ")")
	g.P("}")
	g.P()
	g.P("// Get", interfaceServerName, "FromContainer fetches the downstream di.Request scoped service")
	g.P("func Get", interfaceServerName, "FromContainer(ctn ", diPackage.Ident("Container"), ") ", interfaceServerName, " {")
	g.P("return ctn.GetByType(", typeServerInterfaceName, ").(", interfaceServerName, ")")
	g.P("}")
	g.P()

	// making type look like sarulabsdi genny types
	g.P("// SafeGet", interfaceDownstreamServiceName, "FromContainer fetches the downstream di.Request scoped service")
	g.P("func SafeGet", interfaceDownstreamServiceName, "FromContainer(ctn ", diPackage.Ident("Container"), ") (", interfaceDownstreamServiceName, ",error) {")
	g.P("obj, err := ctn.SafeGetByType(", typeDownstreamServiceInterfaceName, ")")
	g.P("if err != nil {")
	g.P("    return nil, err")
	g.P("}")
	g.P("return obj.(", interfaceDownstreamServiceName, "),nil")
	g.P("}")
	g.P()

	g.P("// SafeGet", interfaceServerName, "FromContainer fetches the downstream di.Request scoped service")
	g.P("func SafeGet", interfaceServerName, "FromContainer(ctn ", diPackage.Ident("Container"), ") (", interfaceServerName, ",error) {")
	g.P("obj, err := ctn.SafeGetByType(", typeServerInterfaceName, ")")
	g.P("if err != nil {")
	g.P("    return nil, err")
	g.P("}")
	g.P("return obj.(", interfaceServerName, "),nil")
	g.P("}")
	g.P()
	// Instance Impl
	g.P("// Impl for ", service.GoName, " server instances")
	g.P("type ", strings.ToLower(service.GoName), "Server struct {")
	g.P(unimplementedExServerName)
	g.P("}")
	g.P("// Impl for ", service.GoName, " server instances")
	g.P("type ", strings.ToLower(service.GoName), "ServerV2 struct {")
	g.P(unimplementedExServerName)
	g.P("}")

	// Server Registration
	g.P("// Register", service.GoName, "ServerDI ...")
	g.P("func Register", service.GoName, "ServerDI(s ", grpcPackage.Ident("ServiceRegistrar"), ") interface{} {")
	g.P("// Register the server")
	g.P("var server = &", strings.ToLower(service.GoName), "Server{ }")
	g.P("Register", service.GoName, "Server(s, server)")
	g.P("return server")
	g.P("}")
	g.P()
	g.P("// Register", service.GoName, "ServerDIV2 ...")
	g.P("func Register", service.GoName, "ServerDIV2(s ", grpcPackage.Ident("ServiceRegistrar"), ") interface{} {")
	g.P("// Register the server")
	g.P("var server = &", strings.ToLower(service.GoName), "ServerV2{ }")
	g.P("Register", service.GoName, "Server(s, server)")
	g.P("return server")
	g.P("}")
	g.P()
	// Client method implementations.
	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		methodGenCtx := s.MethodMapGenCtx[key]
		methodGenCtx.genServerMethodShim()
	}
	g.P("// FullMethodNames for ", service.GoName)
	g.P("const (")
	for _, method := range service.Methods {
		serverType := method.Parent.GoName
		key := "/" + *proto.Package + "." + serverType + "/" + method.GoName
		g.P("// FMN_", serverType, "_", method.GoName)
		g.P("FMN_", serverType, "_", method.GoName, " = \"", key, "\"")
	}
	g.P(")")
}

func (s *methodGenContext) genDownstreamMethodSignature() {
	g := s.g
	if s.ProtogenMethod.Desc.IsStreamingClient() || s.ProtogenMethod.Desc.IsStreamingServer() {
		// Explicitly no current support for streaming methods
		//panic("Does not currently support streaming methods")
		return
	}
	// Unary method
	g.P(s.downstreamServiceSignature())
	g.P()
}

func (s *methodGenContext) genServerMethodShim() {
	service := s.service
	g := s.g

	method := s.ProtogenMethod

	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		// Explicitly no current support for streaming methods
		//	panic("Does not currently support streaming methods")
		return
	}

	// Unary method
	serverType := method.Parent.GoName

	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		s.MethodInfo.NewResponseFunc = fmt.Sprintf(
			`func() interface{} {
				ret := &%v{}
				return ret 
			}`, g.QualifiedGoIdent(method.Output.GoIdent))

		s.MethodInfo.NewResponseWithErrorFunc = fmt.Sprintf(
			`func() interface{} {
				ret := &%v{}
				setNewField_%v(ret, "Error")
				return ret 
			}`, g.QualifiedGoIdent(method.Output.GoIdent), s.uniqueRunID)

		s.MethodInfo.ExecuteFunc = fmt.Sprintf(
			`func(service I%vServer, ctx context.Context, request interface{}) (interface{}, error) {
				req := request.(*%v)
				return service.%v(ctx, req)
			}`, service.GoName, g.QualifiedGoIdent(method.Input.GoIdent),
			method.GoName,
		)
	}
	/*
	   var dd = map[string]func(service *greeter2Server, ctx context.Context, request interface{}) (interface{}, error){
	   	"/helloworld.Greeter/SayHello": func(service *greeter2Server, ctx context.Context, request interface{}) (interface{}, error) {
	   		req := request.(*HelloRequest)
	   		return service.SayHello(ctx, req)
	   	},
	   }
	*/

	g.P("// ", s.ProtogenMethod.GoName, "...")
	g.P("func (s *", strings.ToLower(serverType), "Server) ", s.serverSignature(), "{")
	g.P("requestContainer := ", diContextPackage.Ident("GetRequestContainer(ctx)"))
	g.P("downstreamService := Get", service.GoName, "ServiceFromContainer(requestContainer)")
	g.P("return downstreamService.", method.GoName, "(request)")
	g.P("}")
	g.P()

	g.P("// ", s.ProtogenMethod.GoName, "...")
	g.P("func (s *", strings.ToLower(serverType), "ServerV2) ", s.serverSignature(), "{")
	g.P("requestContainer := ", diContextPackage.Ident("GetRequestContainer(ctx)"))
	g.P("downstreamService := Get", service.GoName, "ServerFromContainer(requestContainer)")
	g.P("return downstreamService.", method.GoName, "(ctx,request)")
	g.P("}")
	g.P()
}

func (s *methodGenContext) downstreamServiceSignature() string {
	g := s.g
	method := s.ProtogenMethod
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		ret = "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "request *"+g.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, method.Parent.GoName+"_"+method.GoName+"Server")
	}
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
func (s *methodGenContext) serverSignature() string {
	g := s.g
	method := s.ProtogenMethod
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "ctx "+g.QualifiedGoIdent(contextPackage.Ident("Context")))
		ret = "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "request *"+g.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, method.Parent.GoName+"_"+method.GoName+"Server")
	}
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
func prettyJSON(obj interface{}) string {
	jsonBytes, err := json.MarshalIndent(obj, "", "    ")
	if err != nil {
		panic(err)
	}
	return string(jsonBytes)
}
