package main

import (
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	contextPackage        = protogen.GoImportPath("context")
	errorsPackage         = protogen.GoImportPath("errors")
	grpcPackage           = protogen.GoImportPath("google.golang.org/grpc")
	protoreflectPackage   = protogen.GoImportPath("google.golang.org/protobuf/reflect/protoreflect")
	diSarulabsPackage     = protogen.GoImportPath("github.com/sarulabs/di")
	grpcDIInternalPackage = protogen.GoImportPath("github.com/fluffy-bunny/grpcdotnetgo")
	diContextPackage      = protogen.GoImportPath("github.com/fluffy-bunny/grpcdotnetgo/middleware/dicontext")
)

// generateFile generates a _gtm.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_di.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-di. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

// generateFileContent generates the DI service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the grpc package it is being compiled against.")
	g.P("const _ = ", grpcDIInternalPackage.Ident("SupportPackageIsVersion7"))
	g.P()

	// Generate each service
	for _, service := range file.Services {

		genService(gen, file, g, service)
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("// ", service.GoName, "Service defines the required downstream service interface")
	g.P("type ", service.GoName, "Service ", "interface {")
	for _, method := range service.Methods {
		genDownstreamMethodSignature(gen, file, g, method)
	}
	g.P("}")
	g.P()

	// ServiceName is the unique service name that MUST be used to register the downstream service in the DI
	g.P("// di", service.GoName, "ServiceName is the unique service name that MUST be used to register the downstream service in the DI")
	g.P("const di", service.GoName, "ServiceName", " = \"grpc-downstreamservice-", service.GoName, "\"")

	// Getter for the ServiceName
	g.P("// Get", service.GoName, "ServiceName is a getter to fetch the unique service name.")
	g.P("func Get", service.GoName, "ServiceName() string {")
	g.P("return di", service.GoName, "ServiceName")
	g.P("}")
	g.P()

	// DI Getter
	g.P("// Get", service.GoName, "FromContainer fetches the downstream di.Request scoped service")
	g.P("func Get", service.GoName, "FromContainer(ctn ", diSarulabsPackage.Ident("Container"), ") ", service.GoName, "Service {")
	g.P("return ctn.Get(Get", service.GoName, "ServiceName()).(", service.GoName, "Service)")
	g.P("}")
	g.P()

	// Instance Impl
	g.P("// Impl for ", service.GoName, " server instances")
	g.P("type ", strings.ToLower(service.GoName), "Server struct {")
	g.P("Unimplemented", service.GoName, "Server")
	g.P("}")

	// Server Registration
	g.P("func Register", service.GoName, "ServerDI(s ", grpcPackage.Ident("ServiceRegistrar"), ") {")
	g.P("// Register the server")
	g.P("Register", service.GoName, "Server(s, &", strings.ToLower(service.GoName), "Server{ })")
	g.P("}")
	g.P()

	// Client method implementations.
	for _, method := range service.Methods {
		genServerMethodShim(service, gen, file, g, method)
	}
}

func genDownstreamMethodSignature(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, method *protogen.Method) {
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		// Explicitly no current support for streaming methods
		panic("GTM does not currently support streaming methods")
	}
	// Unary method
	g.P(downstreamServiceSignature(g, method))
	g.P()
}

func genServerMethodShim(service *protogen.Service, gen *protogen.Plugin, file *protogen.File,
	g *protogen.GeneratedFile, method *protogen.Method) {
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		// Explicitly no current support for streaming methods
		panic("GTM does not currently support streaming methods")
	}

	// Unary method
	serverType := method.Parent.GoName
	g.P("func (s *", strings.ToLower(serverType), "Server) ", serverSignature(g, method), "{")
	g.P("requestContainer := ", diContextPackage.Ident("GetRequestContainer(ctx)"))
	g.P("downstreamService := Get", service.GoName, "FromContainer(requestContainer)")
	g.P("return downstreamService.", method.GoName, "(request)")
	g.P("}")
	g.P()
}

func downstreamServiceSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		ret = "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "request *"+g.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, method.Parent.GoName+"_"+method.GoName+"Server")
	}
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
func serverSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "ctx "+g.QualifiedGoIdent(contextPackage.Ident("Context")))
		ret = "(*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "request *"+g.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, method.Parent.GoName+"_"+method.GoName+"Server")
	}
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}
